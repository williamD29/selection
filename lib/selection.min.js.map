{"version":3,"file":"selection.min.js","sources":["../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/removeElement.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/index.ts","../src/EventEmitter.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport {Properties} from 'csstype';\r\n\r\nconst unitify = (val: string | number, unit = 'px'): string => {\r\n    return typeof val === 'number' ? val + unit : val;\r\n};\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(\r\n    {style}: HTMLElement,\r\n    attr: Partial<Record<keyof Properties, string | number>> | keyof Properties,\r\n    val?: string | number\r\n): void {\r\n    if (typeof attr === 'object') {\r\n\r\n        for (const [key, value] of Object.entries(attr)) {\r\n            style[key as any] = unitify(value as string | number);\r\n        }\r\n\r\n    } else if (val !== undefined) {\r\n        style[attr as any] = unitify(val);\r\n    }\r\n}\r\n\r\n\r\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype Method = 'addEventListener' | 'removeEventListener';\r\ntype AnyFunction = (...arg: any) => any;\r\n\r\nexport type EventBindingArgs = [\r\n        EventTarget | Array<EventTarget>,\r\n        string | Array<string>,\r\n    AnyFunction,\r\n    Record<string, unknown>?\r\n];\r\n\r\ninterface EventBinding {\r\n    (\r\n        elements: EventTarget | Array<EventTarget>,\r\n        events: string | Array<string>,\r\n        fn: AnyFunction,\r\n        options?: Record<string, unknown>\r\n    ): EventBindingArgs;\r\n}\r\n\r\n/* eslint-disable prefer-rest-params */\r\nfunction eventListener(method: Method): EventBinding {\r\n    return (\r\n        items: EventTarget | Array<EventTarget>,\r\n        events: string | Array<string>,\r\n        fn: AnyFunction, options = {}\r\n    ): EventBindingArgs => {\r\n\r\n        // Normalize array\r\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\r\n            items = Array.from(items);\r\n        } else if (!Array.isArray(items)) {\r\n            items = [items];\r\n        }\r\n\r\n        if (!Array.isArray(events)) {\r\n            events = [events];\r\n        }\r\n\r\n        for (const el of items) {\r\n            for (const ev of events) {\r\n                el[method](ev, fn as EventListener, {capture: false, ...options});\r\n            }\r\n        }\r\n\r\n        return [items, events, fn, options];\r\n    };\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener('addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener('removeEventListener');\r\n\r\n/**\r\n * Simplifies a touch / mouse-event\r\n * @param evt\r\n */\r\nexport const simplifyEvent = (evt: any): {\r\n    tap: MouseEvent | Touch;\r\n    x: number;\r\n    y: number;\r\n    target: HTMLElement;\r\n} => {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n};\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt: any): Array<EventTarget> {\r\n    let path: Array<EventTarget> = evt.path || (evt.composedPath && evt.composedPath());\r\n    if (path) {\r\n        return path;\r\n    }\r\n\r\n    let el = evt.target.parentElement;\r\n    path = [evt.target, el];\r\n    while (el = el.parentElement) {\r\n        path.push(el);\r\n    }\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n","export type Intersection = 'center' | 'cover' | 'touch'\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\r\n    switch (mode) {\r\n        case 'center': {\r\n            const bxc = b.left + b.width / 2;\r\n            const byc = b.top + b.height / 2;\r\n\r\n            return bxc >= a.left &&\r\n                bxc <= a.right &&\r\n                byc >= a.top &&\r\n                byc <= a.bottom;\r\n        }\r\n        case 'cover': {\r\n            return b.left >= a.left &&\r\n                b.top >= a.top &&\r\n                b.right <= a.right &&\r\n                b.bottom <= a.bottom;\r\n        }\r\n        case 'touch': {\r\n            return a.right >= b.left &&\r\n                a.left <= b.right &&\r\n                a.bottom >= b.top &&\r\n                a.top <= b.bottom;\r\n        }\r\n        default: {\r\n            throw new Error(`Unkown intersection mode: ${mode}`);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement<T>(arr: T[], el: T): void {\r\n    const index = arr.indexOf(el);\r\n\r\n    if (~index) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @param doc\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Array<Element> {\r\n    const list = !Array.isArray(selector) ? [selector] : selector;\r\n\r\n    const nodes = [];\r\n    for (let i = 0, l = list.length; i < l; i++) {\r\n        const item = list[i];\r\n\r\n        if (typeof item === 'string') {\r\n            nodes.push(...Array.from(doc.querySelectorAll(item)));\r\n        } else if (item instanceof HTMLElement) {\r\n            nodes.push(item);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n","// Determines if the device's primary input supports touch\r\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\r\nexport const isTouchDevice = window.matchMedia('(hover: none), (pointer: coarse)').matches;\r\n","import {\r\n  css,\r\n  eventPath,\r\n  intersects,\r\n  isTouchDevice,\r\n  off,\r\n  on,\r\n  removeElement,\r\n  selectAll,\r\n  SelectAllSelectors,\r\n  simplifyEvent,\r\n} from '@utils';\r\nimport { EventTarget } from './EventEmitter';\r\nimport { AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore } from './types';\r\n\r\n// Re-export types\r\nexport * from './types';\r\n\r\n// Some var shorting for better compression and readability\r\nconst { abs, max, min, ceil } = Math;\r\n\r\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\r\n  public static version = VERSION;\r\n\r\n  // Options\r\n  private readonly _options: SelectionOptions;\r\n\r\n  // Selection store\r\n  private _selection: SelectionStore = {\r\n    touched: [],\r\n    stored: [],\r\n    selected: [],\r\n    changed: {\r\n      added: [], // Added elements since last selection\r\n      removed: [], // Removed elements since last selection\r\n    },\r\n  };\r\n\r\n  // Area element and clipping element\r\n  private readonly _area: HTMLElement;\r\n  private readonly _clippingElement: HTMLElement;\r\n\r\n  // Target container (element) and boundary (cached)\r\n  private _targetElement?: Element;\r\n  private _targetRect?: DOMRect;\r\n  private _selectables: Array<Element> = [];\r\n\r\n  // Caches the position of the selection-area\r\n  private readonly _areaRect = new DOMRect();\r\n\r\n  // Dynamically constructed area rect\r\n  private _areaLocation: AreaLocation = { y1: 0, x2: 0, y2: 0, x1: 0 };\r\n\r\n  // If a single click is being performed.\r\n  // It's a single-click until the user dragged the mouse.\r\n  private _singleClick = true;\r\n\r\n  // Is getting set on movement. Varied.\r\n  private _scrollAvailable = true;\r\n  private _scrollSpeed: Coordinates = { x: 0, y: 0 };\r\n  private _scrollDelta: Coordinates = { x: 0, y: 0 };\r\n\r\n  constructor(opt: Partial<SelectionOptions>) {\r\n    super();\r\n\r\n    this._options = Object.assign(\r\n      {\r\n        class: 'selection-area',\r\n        document: window.document,\r\n        intersect: 'touch',\r\n        startThreshold: 10,\r\n        singleClick: true,\r\n        allowTouch: true,\r\n        overlap: 'invert',\r\n        selectables: [],\r\n\r\n        singleTap: {\r\n          allow: true,\r\n          intersect: 'native',\r\n        },\r\n\r\n        scrolling: {\r\n          speedDivider: 10,\r\n          manualSpeed: 750,\r\n        },\r\n\r\n        startareas: ['html'],\r\n        boundaries: ['html'],\r\n        container: 'body',\r\n      },\r\n      opt\r\n    );\r\n\r\n    // Bind locale functions to instance\r\n    /* eslint-disable @typescript-eslint/no-explicit-any */\r\n    for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\r\n      if (typeof (this as any)[key] === 'function') {\r\n        (this as any)[key] = (this as any)[key].bind(this);\r\n      }\r\n    }\r\n\r\n    const { document } = this._options;\r\n    this._area = document.createElement('div');\r\n    this._clippingElement = document.createElement('div');\r\n    this._clippingElement.appendChild(this._area);\r\n\r\n    // Add class to the area element\r\n    this._area.classList.add(this._options.class);\r\n\r\n    // Apply basic styles to the area element\r\n    css(this._area, {\r\n      willChange: 'top, left, bottom, right, width, height',\r\n      top: 0,\r\n      left: 0,\r\n      position: 'fixed',\r\n    });\r\n\r\n    css(this._clippingElement, {\r\n      overflow: 'hidden',\r\n      position: 'fixed',\r\n      transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n      pointerEvents: 'none',\r\n      zIndex: 5,\r\n    });\r\n\r\n    this.enable();\r\n  }\r\n\r\n  _bindStartEvents(activate = true): void {\r\n    const { document, allowTouch } = this._options;\r\n    const fn = activate ? on : off;\r\n\r\n    fn(document, 'mousedown', this._onTapStart);\r\n    allowTouch &&\r\n      fn(document, 'touchstart', this._onTapStart, {\r\n        passive: false,\r\n      });\r\n  }\r\n\r\n  _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\r\n    const { x, y, target } = simplifyEvent(evt);\r\n    const { _options } = this;\r\n    const { document } = this._options;\r\n    const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n    // Find start-areas and boundaries\r\n    const startAreas = selectAll(_options.startareas, _options.document);\r\n    const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\r\n\r\n    // Check in which container the user currently acts\r\n    this._targetElement = resolvedBoundaries.find((el) =>\r\n      intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n    );\r\n\r\n    // Check if area starts in one of the start areas / boundaries\r\n    const evtpath = eventPath(evt);\r\n    if (\r\n      !this._targetElement ||\r\n      !startAreas.find((el) => evtpath.includes(el)) ||\r\n      !resolvedBoundaries.find((el) => evtpath.includes(el))\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    if (!silent && this._emitEvent('beforestart', evt) === false) {\r\n      return;\r\n    }\r\n\r\n    // Area rect\r\n    this._areaLocation = { x1: x, y1: y, x2: 0, y2: 0 };\r\n\r\n    // Lock scrolling in target container\r\n    // Solution to preventing scrolling taken fr\r\n    const scrollElement = document.scrollingElement || document.body;\r\n    this._scrollDelta = { x: scrollElement.scrollLeft, y: scrollElement.scrollTop };\r\n\r\n    // To detect single-click\r\n    this._singleClick = true;\r\n    this.clearSelection(false);\r\n\r\n    // Add listener\r\n    on(document, ['touchmove', 'mousemove'], this._delayedTapMove, { passive: false });\r\n    on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n    on(document, 'scroll', this._onScroll);\r\n  }\r\n\r\n  _onSingleTap(evt: MouseEvent | TouchEvent): void {\r\n    const { intersect } = this._options.singleTap;\r\n    const spl = simplifyEvent(evt);\r\n    let target = null;\r\n\r\n    if (intersect === 'native') {\r\n      target = spl.target;\r\n    } else if (intersect === 'touch') {\r\n      this.resolveSelectables();\r\n\r\n      const { x, y } = spl;\r\n      target = this._selectables.find((v) => {\r\n        const { right, left, top, bottom } = v.getBoundingClientRect();\r\n        return x < right && x > left && y < bottom && y > top;\r\n      });\r\n    }\r\n\r\n    if (!target) {\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * Resolve selectables again.\r\n     * If the user starded in a scrollable area they will be reduced\r\n     * to the current area. Prevent the exclusion of these if a range-selection\r\n     * gets performed.\r\n     */\r\n    this.resolveSelectables();\r\n\r\n    // Traverse dom upwards to check if target is selectable\r\n    while (!this._selectables.includes(target)) {\r\n      if (!target.parentElement) {\r\n        return;\r\n      }\r\n\r\n      target = target.parentElement;\r\n    }\r\n\r\n    // Grab current store first in case it gets resetted\r\n    const { stored } = this._selection;\r\n\r\n    // Emit event and process element\r\n    this._emitEvent('start', evt);\r\n    if (evt.shiftKey && stored.length) {\r\n      const reference = stored[stored.length - 1];\r\n\r\n      // Resolve correct range\r\n      const [preceding, following] =\r\n        reference.compareDocumentPosition(target) & 4 ? [target, reference] : [reference, target];\r\n\r\n      const rangeItems = [\r\n        ...this._selectables.filter(\r\n          (el) => el.compareDocumentPosition(preceding) & 4 && el.compareDocumentPosition(following) & 2\r\n        ),\r\n        target,\r\n        preceding,\r\n        following,\r\n      ];\r\n\r\n      this.select(rangeItems);\r\n    } else if (stored.includes(target) && (stored.length === 1 || evt.ctrlKey)) {\r\n      this.deselect(target);\r\n    } else {\r\n      this.select(target);\r\n    }\r\n\r\n    this._emitEvent('stop', evt);\r\n  }\r\n\r\n  _delayedTapMove(evt: MouseEvent | TouchEvent): void {\r\n    const { startThreshold, container, document, allowTouch } = this._options;\r\n    const { x1, y1 } = this._areaLocation; // Coordinates of first \"tap\"\r\n    const { x, y } = simplifyEvent(evt);\r\n\r\n    // Check pixel threshold\r\n    const thresholdType = typeof startThreshold;\r\n    if (\r\n      // Single number\r\n      (thresholdType === 'number' && abs(x + y - (x1 + y1)) >= startThreshold) ||\r\n      // Different x and y threshold\r\n      (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x) ||\r\n      abs(y - y1) >= (startThreshold as Coordinates).y\r\n    ) {\r\n      off(document, ['mousemove', 'touchmove'], this._delayedTapMove, { passive: false });\r\n      on(document, ['mousemove', 'touchmove'], this._onTapMove, { passive: false });\r\n\r\n      // Make area element visible\r\n      css(this._area, 'display', 'block');\r\n\r\n      // Apppend selection-area to the dom\r\n      selectAll(container, document)[0].appendChild(this._clippingElement);\r\n\r\n      // Now after the threshold is reached resolve all selectables\r\n      this.resolveSelectables();\r\n\r\n      // An action is recognized as single-select until the user performed a mutli-selection\r\n      this._singleClick = false;\r\n\r\n      // Just saving the boundaries of this container for later\r\n      this._targetRect = this._targetElement!.getBoundingClientRect();\r\n\r\n      // Find container and check if it's scrollable\r\n      this._scrollAvailable =\r\n        this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\r\n        this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\r\n\r\n      if (this._scrollAvailable) {\r\n        // Detect mouse scrolling\r\n        on(document, 'wheel', this._manualScroll, { passive: false });\r\n\r\n        /**\r\n         * The selection-area will also cover other element which are\r\n         * out of the current scrollable parent. So find all elements\r\n         * which are in the current scrollable element. Later these are\r\n         * the only selectables instead of all.\r\n         */\r\n        this._selectables = this._selectables.filter((s) => this._targetElement!.contains(s));\r\n      }\r\n\r\n      // Trigger recalc and fire event\r\n      this._prepareSelectionArea();\r\n      this._emitEvent('start', evt);\r\n      this._onTapMove(evt);\r\n    }\r\n\r\n    if (allowTouch && isTouchDevice) {\r\n      evt.preventDefault(); // Prevent swipe-down refresh\r\n    }\r\n  }\r\n\r\n  _prepareSelectionArea(): void {\r\n    const { _clippingElement, _targetElement, _area } = this;\r\n    const tr = (this._targetRect = _targetElement!.getBoundingClientRect());\r\n\r\n    if (this._scrollAvailable) {\r\n      /**\r\n       * To clip the area, the selection area has a parent\r\n       * which has exact the same dimensions as the scrollable elemeent.\r\n       * Now if the area exeeds these boundaries it will be cropped.\r\n       */\r\n      css(_clippingElement, {\r\n        top: tr.top,\r\n        left: tr.left,\r\n        width: tr.width,\r\n        height: tr.height,\r\n      });\r\n\r\n      /**\r\n       * The area element is relative to the clipping element,\r\n       * but when this is moved or transformed we need to correct\r\n       * the positions via a negative margin.\r\n       */\r\n      css(_area, {\r\n        marginTop: -tr.top,\r\n        marginLeft: -tr.left,\r\n      });\r\n    } else {\r\n      /**\r\n       * Reset margin and clipping element dimensions.\r\n       */\r\n      css(_clippingElement, {\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n      });\r\n\r\n      css(_area, {\r\n        marginTop: 0,\r\n        marginLeft: 0,\r\n      });\r\n    }\r\n  }\r\n\r\n  _onTapMove(evt: MouseEvent | TouchEvent): void {\r\n    const { x, y } = simplifyEvent(evt);\r\n    const { _scrollSpeed, _areaLocation, _options } = this;\r\n    const { allowTouch } = _options;\r\n    const { speedDivider } = _options.scrolling;\r\n    const scon = this._targetElement as Element;\r\n\r\n    _areaLocation.x2 = x;\r\n    _areaLocation.y2 = y;\r\n\r\n    if (this._scrollAvailable && (_scrollSpeed.y || _scrollSpeed.x)) {\r\n      const scroll = () => {\r\n        if (!_scrollSpeed.x && !_scrollSpeed.y) {\r\n          return;\r\n        }\r\n\r\n        /**\r\n         * If the value exeeds the scrollable area it will\r\n         * be set to the max / min value. So change only\r\n         */\r\n        const { scrollTop, scrollLeft } = scon;\r\n\r\n        // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\r\n        if (_scrollSpeed.y) {\r\n          scon.scrollTop += ceil(_scrollSpeed.y / speedDivider);\r\n          _areaLocation.y1 -= scon.scrollTop - scrollTop;\r\n        }\r\n\r\n        if (_scrollSpeed.x) {\r\n          scon.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\r\n          _areaLocation.x1 -= scon.scrollLeft - scrollLeft;\r\n        }\r\n\r\n        /**\r\n         * We changed the start coordinates -> redraw the selectiona area\r\n         * We changed the dimensions of the area element -> re-calc selected elements\r\n         * The selected elements array has been changed -> fire event\r\n         */\r\n        this._recalculateSelectionAreaRect();\r\n        this._updateElementSelection();\r\n        this._emitEvent('move', evt);\r\n        this._redrawSelectionArea();\r\n\r\n        // Keep scrolling even if the user stops to move his pointer\r\n        requestAnimationFrame(scroll);\r\n      };\r\n\r\n      // Continous scrolling\r\n      requestAnimationFrame(scroll);\r\n    } else {\r\n      /**\r\n       * Perform redraw only if scrolling is not active.\r\n       * If scrolling is active this area is getting re-dragwed by the\r\n       * anonymized scroll function.\r\n       */\r\n      this._recalculateSelectionAreaRect();\r\n      this._updateElementSelection();\r\n      this._emitEvent('move', evt);\r\n      this._redrawSelectionArea();\r\n    }\r\n\r\n    if (allowTouch && isTouchDevice) {\r\n      evt.preventDefault(); // Prevent swipe-down refresh\r\n    }\r\n  }\r\n\r\n  _onScroll(): void {\r\n    const {\r\n      _scrollDelta,\r\n      _options: { document },\r\n    } = this;\r\n\r\n    // Resolve scrolling offsets\r\n    const { scrollTop, scrollLeft } = document.scrollingElement || document.body;\r\n\r\n    // Adjust area start location\r\n    this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\r\n    this._areaLocation.y1 += _scrollDelta.y - scrollTop;\r\n    _scrollDelta.x = scrollLeft;\r\n    _scrollDelta.y = scrollTop;\r\n\r\n    // The area needs to be resetted as the target-container has changed in its position\r\n    this._prepareSelectionArea();\r\n    this._recalculateSelectionAreaRect();\r\n    this._updateElementSelection();\r\n    this._emitEvent('move', null);\r\n    this._redrawSelectionArea();\r\n  }\r\n\r\n  _manualScroll(evt: ScrollEvent): void {\r\n    const { manualSpeed } = this._options.scrolling;\r\n\r\n    // Consistent scrolling speed on all browsers\r\n    const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\r\n    const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\r\n    this._scrollSpeed.y += deltaY * manualSpeed;\r\n    this._scrollSpeed.x += deltaX * manualSpeed;\r\n    this._onTapMove(evt);\r\n\r\n    // Prevent defaul scrolling behaviour, eg. page scrolling\r\n    evt.preventDefault();\r\n  }\r\n\r\n  _recalculateSelectionAreaRect(): void {\r\n    const { _scrollSpeed, _areaLocation, _areaRect, _targetElement, _targetRect } = this;\r\n    const { scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth } = _targetElement as Element;\r\n    const brect = _targetRect as DOMRect;\r\n    let { x1, y1, x2, y2 } = _areaLocation;\r\n\r\n    if (x2 < brect.left) {\r\n      _scrollSpeed.x = scrollLeft ? -abs(brect.left - x2) : 0;\r\n      x2 = brect.left;\r\n    } else if (x2 > brect.right) {\r\n      _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x2) : 0;\r\n      x2 = brect.right;\r\n    } else {\r\n      _scrollSpeed.x = 0;\r\n    }\r\n\r\n    if (y2 < brect.top) {\r\n      _scrollSpeed.y = scrollTop ? -abs(brect.top - y2) : 0;\r\n      y2 = brect.top;\r\n    } else if (y2 > brect.bottom) {\r\n      _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y2) : 0;\r\n      y2 = brect.bottom;\r\n    } else {\r\n      _scrollSpeed.y = 0;\r\n    }\r\n\r\n    const x3 = min(x1, x2);\r\n    const y3 = min(y1, y2);\r\n    const x4 = max(x1, x2);\r\n    const y4 = max(y1, y2);\r\n\r\n    _areaRect.x = x3;\r\n    _areaRect.y = y3;\r\n    _areaRect.width = x4 - x3;\r\n    _areaRect.height = y4 - y3;\r\n  }\r\n\r\n  _redrawSelectionArea(): void {\r\n    const { x, y, width, height } = this._areaRect;\r\n    const { style } = this._area;\r\n\r\n    // Using transform will make the area's borders look blurry\r\n    style.left = `${x}px`;\r\n    style.top = `${y}px`;\r\n    style.width = `${width}px`;\r\n    style.height = `${height}px`;\r\n  }\r\n\r\n  _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\r\n    const { document, singleTap } = this._options;\r\n    const { _singleClick } = this;\r\n\r\n    // Remove event handlers\r\n    off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\r\n    off(document, ['touchmove', 'mousemove'], this._onTapMove);\r\n    off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n    off(document, 'scroll', this._onScroll);\r\n\r\n    if (evt && _singleClick && singleTap.allow) {\r\n      this._onSingleTap(evt);\r\n    } else if (!_singleClick && !silent) {\r\n      this._updateElementSelection();\r\n      this._emitEvent('stop', evt);\r\n    }\r\n\r\n    // Reset scroll speed\r\n    this._scrollSpeed.x = 0;\r\n    this._scrollSpeed.y = 0;\r\n\r\n    // Unbind mouse scrolling listener\r\n    this._scrollAvailable && off(document, 'wheel', this._manualScroll, { passive: true });\r\n\r\n    // Remove selection-area from dom\r\n    this._clippingElement.remove();\r\n\r\n    // Hide selection area\r\n    css(this._area, 'display', 'none');\r\n  }\r\n\r\n  _updateElementSelection(): void {\r\n    const { _selectables, _options, _selection, _areaRect } = this;\r\n    const { stored, selected, touched } = _selection;\r\n    const { intersect, overlap } = _options;\r\n\r\n    // Update\r\n    const newlyTouched = [];\r\n    const added = [];\r\n    const removed = [];\r\n\r\n    // Itreate over the selectable elements\r\n    for (let i = 0; i < _selectables.length; i++) {\r\n      const node = _selectables[i];\r\n\r\n      // Check if area intersects element\r\n      if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\r\n        // Check if the element wasn't present in the last selection.\r\n        if (!selected.includes(node)) {\r\n          // Check if user wants to invert the selection for already selected elements\r\n          if (overlap === 'invert' && stored.includes(node)) {\r\n            removed.push(node);\r\n            continue;\r\n          } else {\r\n            added.push(node);\r\n          }\r\n        } else if (stored.includes(node) && !touched.includes(node)) {\r\n          touched.push(node);\r\n        }\r\n\r\n        newlyTouched.push(node);\r\n      }\r\n    }\r\n\r\n    // Re-select elements which were previously stored\r\n    if (overlap === 'invert') {\r\n      added.push(...stored.filter((v) => !selected.includes(v)));\r\n    }\r\n\r\n    // Check which elements where removed since last selection\r\n    for (let i = 0; i < selected.length; i++) {\r\n      const node = selected[i];\r\n\r\n      if (\r\n        !newlyTouched.includes(node) &&\r\n        !(\r\n          // Check if user wants to keep previously selected elements, e.g.\r\n          // not make them part of the current selection as soon as they're touched.\r\n          (overlap === 'keep' && stored.includes(node))\r\n        )\r\n      ) {\r\n        removed.push(node);\r\n      }\r\n    }\r\n\r\n    // Save\r\n    _selection.selected = newlyTouched;\r\n    _selection.changed = { added, removed };\r\n  }\r\n\r\n  _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\r\n    return this.emit(name, {\r\n      event: evt,\r\n      store: this._selection,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Manually triggers the start of a selection\r\n   * @param evt A MouseEvent / TouchEvent -like object\r\n   * @param silent If beforestart should be fired,\r\n   */\r\n  trigger(evt: MouseEvent | TouchEvent, silent = true): void {\r\n    this._onTapStart(evt, silent);\r\n  }\r\n\r\n  /**\r\n   * Can be used if during a selection elements have been added.\r\n   * Will update everything which can be selected.\r\n   */\r\n  resolveSelectables(): void {\r\n    // Resolve selectors\r\n    this._selectables = selectAll(this._options.selectables, this._options.document);\r\n  }\r\n\r\n  /**\r\n   * Saves the current selection for the next selecion.\r\n   * Allows multiple selections.\r\n   */\r\n  keepSelection(): void {\r\n    const { _options, _selection } = this;\r\n    const { selected, changed, touched, stored } = _selection;\r\n\r\n    // Newly added elements\r\n    const addedElements = selected.filter((el) => !stored.includes(el));\r\n\r\n    switch (_options.overlap) {\r\n      case 'drop': {\r\n        _selection.stored = addedElements.concat(\r\n          // Elements not touched\r\n          stored.filter((el) => !touched.includes(el))\r\n        );\r\n        break;\r\n      }\r\n      case 'invert': {\r\n        _selection.stored = addedElements.concat(\r\n          // Elements not removed from selection\r\n          stored.filter((el) => !changed.removed.includes(el))\r\n        );\r\n        break;\r\n      }\r\n      case 'keep': {\r\n        _selection.stored = stored.concat(\r\n          // Newly added\r\n          selected.filter((el) => !stored.includes(el))\r\n        );\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear the elements which where saved by 'keepSelection()'.\r\n   * @param store If the store should also get cleared\r\n   */\r\n  clearSelection(store = true): void {\r\n    this._selection = {\r\n      stored: store ? [] : this._selection.stored,\r\n      selected: [],\r\n      touched: [],\r\n      changed: {\r\n        added: [],\r\n        removed: [],\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @returns {Array} Selected elements\r\n   */\r\n  getSelection(): Array<Element> {\r\n    return this._selection.stored;\r\n  }\r\n\r\n  /**\r\n   * @returns {HTMLElement} The selection area element\r\n   */\r\n  getSelectionArea(): HTMLElement {\r\n    return this._area;\r\n  }\r\n\r\n  /**\r\n   * Cancel the current selection process.\r\n   * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n   */\r\n  cancel(keepEvent = false): void {\r\n    this._onTapStop(null, !keepEvent);\r\n  }\r\n\r\n  /**\r\n   * Unbinds all events and removes the area-element\r\n   */\r\n  destroy(): void {\r\n    this.disable();\r\n    this._clippingElement.remove();\r\n  }\r\n\r\n  /**\r\n   * Disable the selection functinality.\r\n   */\r\n  /* eslint-disable no-invalid-this */\r\n  disable = this._bindStartEvents.bind(this, false);\r\n\r\n  /**\r\n   * Disable the selection functinality.\r\n   */\r\n  /* eslint-disable no-invalid-this */\r\n  enable = this._bindStartEvents;\r\n\r\n  /**\r\n   * Adds elements to the selection\r\n   * @param query - CSS Query, can be an array of queries\r\n   * @param quiet - If this should not trigger the move event\r\n   */\r\n  select(query: SelectAllSelectors, quiet = false): Array<Element> {\r\n    const { changed, selected, stored } = this._selection;\r\n    const elements = selectAll(query, this._options.document).filter(\r\n      (el) => !selected.includes(el) && !stored.includes(el)\r\n    );\r\n\r\n    // Update stores\r\n    selected.push(...elements);\r\n    changed.added.push(...elements);\r\n\r\n    !quiet && this._emitEvent('move', null);\r\n    return elements;\r\n  }\r\n\r\n  /**\r\n   * Removes an particular element from the selection.\r\n   * @param el - Element to remove.\r\n   * @param quiet - If this should not trigger the move event\r\n   * @returns boolean - true if the element was successfully removed\r\n   */\r\n  deselect(el: Element, quiet = false): boolean {\r\n    const { selected, stored, changed } = this._selection;\r\n\r\n    if (selected.includes(el) || stored.includes(el)) {\r\n      changed.removed.push(el);\r\n      removeElement(stored, el);\r\n      removeElement(selected, el);\r\n\r\n      // Fire event\r\n      !quiet && this._emitEvent('move', null);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype AnyFunction = (...args: any[]) => any;\r\ntype EventMap = Record<string, AnyFunction>;\r\n\r\nexport class EventTarget<Events extends EventMap> {\r\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\r\n\r\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\r\n        const set = this._listeners.get(event) || new Set();\r\n        this._listeners.set(event, set);\r\n        set.add(cb as AnyFunction);\r\n        return this;\r\n    }\r\n\r\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\r\n        this._listeners.get(event)?.delete(cb as AnyFunction);\r\n        return this;\r\n    }\r\n\r\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\r\n        let ok = true;\r\n        for (const cb of (this._listeners.get(event) || [])) {\r\n            ok = (cb(...data) !== false) && ok;\r\n        }\r\n\r\n        return ok;\r\n    }\r\n\r\n    // Let's also support on, off and emit like node\r\n    /* eslint-disable no-invalid-this */\r\n    public on = this.addEventListener;\r\n    public off = this.removeEventListener;\r\n    public emit = this.dispatchEvent;\r\n}\r\n"],"names":["unitify","val","unit","css","style","attr","key","value","Object","entries","undefined","eventListener","method","items","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","el","ev","capture","on","off","simplifyEvent","evt","tap","touches","x","clientX","y","clientY","target","eventPath","path","composedPath","parentElement","push","document","window","intersects","a","b","mode","bxc","left","width","byc","top","height","right","bottom","Error","removeElement","arr","index","indexOf","splice","selectAll","selector","doc","list","nodes","i","l","length","item","querySelectorAll","HTMLElement","isTouchDevice","matchMedia","matches","abs","max","min","ceil","Math","SelectionArea","[object Object]","this","Map","addEventListener","removeEventListener","dispatchEvent","event","cb","set","_listeners","get","Set","add","delete","data","ok","opt","super","touched","stored","selected","changed","added","removed","DOMRect","y1","x2","y2","x1","_bindStartEvents","bind","_options","assign","class","intersect","startThreshold","singleClick","allowTouch","overlap","selectables","singleTap","allow","scrolling","speedDivider","manualSpeed","startareas","boundaries","container","getOwnPropertyNames","getPrototypeOf","_area","createElement","_clippingElement","appendChild","classList","willChange","position","overflow","transform","pointerEvents","zIndex","enable","activate","_onTapStart","passive","silent","_","targetBoundingClientRect","getBoundingClientRect","startAreas","resolvedBoundaries","_targetElement","find","evtpath","includes","_emitEvent","_areaLocation","scrollElement","scrollingElement","body","_scrollDelta","scrollLeft","scrollTop","_singleClick","clearSelection","_delayedTapMove","_onTapStop","_onScroll","spl","resolveSelectables","_selectables","v","_selection","shiftKey","reference","preceding","following","compareDocumentPosition","rangeItems","filter","select","ctrlKey","deselect","thresholdType","_onTapMove","_targetRect","_scrollAvailable","scrollHeight","clientHeight","scrollWidth","clientWidth","_manualScroll","s","contains","_prepareSelectionArea","preventDefault","T","L","S","tr","marginTop","marginLeft","m","_scrollSpeed","scon","scroll","_recalculateSelectionAreaRect","_updateElementSelection","_redrawSelectionArea","requestAnimationFrame","deltaY","deltaX","h","_areaRect","C","brect","x3","y3","x4","y4","u","_onSingleTap","remove","o","newlyTouched","node","name","emit","store","addedElements","concat","keepEvent","disable","query","quiet","elements"],"mappings":"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"}